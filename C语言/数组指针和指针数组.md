# 数组指针和指针数组



## 1.定义对比

| 类型         | 示例声明       | 核心含义                                |
| :----------- | :------------- | :-------------------------------------- |
| **数组指针** | `int (*p)[3];` | 指针 `p` 指向一个包含 3 个 `int` 的数组 |
| **指针数组** | `int *p[3];`   | 数组 `p` 包含 3 个 `int*` 指针          |



## 2.内存结构对比

#### (1) 数组指针 `int (*p)[3]`

```c
int arr[3] = {1, 2, 3};
int (*p)[3] = &arr;  // p 指向整个数组
```

内存布局：

```c
p → +---------------+
    | 1 | 2 | 3 |   ← 整个数组
    +---------------+
```

- **特点**：
  - `p` 存储的是**整个数组的地址**。
  - 对 `p` 解引用 (`*p`) 得到的是数组本身（类型 `int[3]`）。

#### (2) 指针数组 `int *p[3]`

```c
int a=1, b=2, c=3;
int *p[3] = {&a, &b, &c};  // p 是存放指针的数组
```

内存布局：

```c
p → +-----+-----+-----+
    | &a | &b | &c |   ← 每个元素都是指针
    +-----+-----+-----+
      |     |     |
      v     v     v
      1     2     3
```

- **特点**：
  - `p` 是一个数组，每个元素都是 `int*` 指针。
  - `p[i]` 可以直接访问指向的整数值。



## 3.关键区别

| 特性          | 数组指针 (`int (*p)[n]`) | 指针数组 (`int *p[n]`)         |
| :------------ | :----------------------- | :----------------------------- |
| **本质**      | 一个指针，指向整个数组   | 一个数组，元素全是指针         |
| **sizeof 值** | 指针大小（4/8字节）      | `n * sizeof(int*)`             |
| **+1 的步长** | `n * sizeof(int)` 字节   | `sizeof(int*)` 字节            |
| **常见用途**  | 处理多维数组             | 存储动态分配的指针或字符串数组 |



这里注意数组指针的+1步长，加一是跳过一整个数组

> 由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 *p[i]，而 **p[i] 是一个指针**。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。

> 由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的步长。也就是说，执行 p+1 时，p 要跨过 n 个 int 型数据的长度。数组指针与二维数组联系密切，可以用数组指针来指向一个二维数组

## 4. **典型应用场景**

#### (1) 数组指针的用途

- **传递二维数组**：

  ```c
  void print_matrix(int (*mat)[3], int rows) {
      for(int i=0; i<rows; i++)
          printf("%d %d %d\n", mat[i][0], mat[i][1], mat[i][2]);
  }
  ```

- **动态分配二维数组**：

  ```c
  int (*p)[3] = malloc(sizeof(int[3]) * 4);  // 4行3列
  ```

#### (2) 指针数组的用途

- **字符串数组**：

  ```c
  char *strs[] = {"Hello", "World", "!"};
  ```

- **动态指针管理**：

  ```c
  int *p[3];
  for(int i=0; i<3; i++) 
      p[i] = malloc(sizeof(int));
  ```

------

## 5. **混淆案例解析**

#### 错误理解：

```c
int *p[3];      // 误以为是"指向数组的指针"
int (*p)[3];    // 误以为是"指针的数组"
```

#### 正确理解：

- **运算符优先级**：
  - `[]` 优先级高于 `*`，因此：
    - `int *p[3]` → `int*` 的数组（指针数组）
    - `int (*p)[3]` → 指向 `int[3]` 的指针（数组指针）

------

### 6. **类型系统视角**

- **数组指针**：

  ```c
  int (*p)[3] → 类型构造：int (*)[3]
  ```

- **指针数组**：

  ```c
  int *p[3] → 类型构造：int* [3]
  ```

------

### 7. **总结口诀**

> "括号先看，星号靠边"
>
> - 有括号 `(*p)`：先解引用，是**数组指针**
> - 无括号 `*p[]`：先数组后指针，是**指针数组**

------

### 终极对比示例

```c
int arr[2][3] = {{1,2,3}, {4,5,6}};

// 数组指针：指向二维数组的行
int (*p1)[3] = arr;    // p1 指向 arr[0]
printf("%d", p1[1][2]); // 输出 6 (arr[1][2])

// 指针数组：存放多个指针
int *p2[2] = {arr[0], arr[1]};
printf("%d", p2[1][2]); // 同样输出 6
```

理解这一区别对处理复杂数据结构和内存管理至关重要！





## 8.一定理解

**一个通过数组和下标实现的表达式可以等价地通过指针及其偏移量来实现**，这就是数组和指针的互通之处。但有一点要明确的是，数组和指针并不是完全等价，***指针是一个变量，而数组名不是变量，它数组中第 1 个元素的地址*，数组可以看做是一个用于保存变量的容器**。更直接的方法，我们可以直接看二者的地址，并不一样





**六、指针与结构**

**6.1 简单介绍一下结构**

　　结构是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构将一组相关的变量看做一个单元而不是各自独立的实体，因此结构有助于组织复杂的数据，特别是在大型的程序中。声明一个结构的方式如下：

```c
struct message{　　　　　　      // 声明一个结构 message
    char name[10];              // 成员
    int age;
    int score;  
};

typedef struct message s_message;　　　　 // 类型定义符 typedef
s_message mess = {"tongye",23,83};　　　　// 声明一个 struct message 类型的变量 mess,并对其进行初始化　
--------------------------------------------------------------------------------------------------------------
/* 另一种更简便的声明方法 */
typedef struct{
　　char name[10];
　　int age;
　　int score;
}message;
```

　　可以使用 **结构名.成员** 的方式来访问结构中的成员，如下：

```c
#include "stdio.h"
int main(){
　　printf("%s\n",mess.name);　　　　// 输出结果：tongye
　　printf("%d\n",mess.age);　　　　 // 输出结果：23
　　return 0;
}
```

**6.2 结构指针**　

　　结构指针是指向结构的指针，以上面的结构为例，可以这样定义一个结构指针：

```c
s_message *p;         // 声明一个结构指针 p ，该指针指向一个 s_message 类型的结构
*p = &mess;　　　　　　// 对结构指针的初始化与普通指针一样，也是使用取地址符 &
```

　　C语言中使用 -> 操作符来访问结构指针的成员，举个例子：

```c
#include "stdio.h"
typedef struct{
    char name[10];
    int age;
    int score;  
}message;

int main(){
    message mess = {"tongye",23,83};
    message *p = &mess;
    printf("%s\n",p->name);　　　　　　// 输出结果为：tongye
    printf("%d\n",p->score);         // 输出结果为：83
    return 0;
} 
```

**七、指针与函数**

　　**C语言的所有参数均是以“传值调用”的方式进行传递的**，这意味着函数将获得参数值的一份拷贝。这样，函数可以放心修改这个拷贝值，而不必担心会修改调用程序实际传递给它的参数。

**7.1 指针作为函数的参数**

　　传值调用的好处是是被调函数不会改变调用函数传过来的值，可以放心修改。但是有时候需要被调函数回传一个值给调用函数，这样的话，传值调用就无法做到。为了解决这个问题，可以使用传指针调用。**指针参数使得被调函数能够访问和修改主调函数中对象的值。**用一个例子来说明：

```c
#include "stdio.h"
void swap1(int a,int b)　　　　　　  // 参数为普通的 int 变量
{
　　int temp;
　　temp = a;
　　a = b;
　　b = temp;
}

void swap2(int *a,int *b)　　　　　　// 参数为指针，接受调用函数传递过来的变量地址作为参数，对所指地址处的内容进行操作
{
　　int temp;　　　　                // 最终结果是，地址本身并没有改变，但是这一地址所对应的内存段中的内容发生了变化，即x,y的值发生了变化
　　temp = *a;
　　*a = *b;
　　*b = temp;
}

int main()
{
　　int x = 1,y = 2;
　　swap1(x,y);                     // 将 x,y 的值本身作为参数传递给了被调函数
　　printf("%d %5d\n",x,y);         // 输出结果为：1     2
　　swap(&x,&y);                    // 将 x,y 的地址作为参数传递给了被调函数，传递过去的也是一个值，与传值调用不冲突
　　printf("%d %5d\n",x,y);         // 输出结果为：2     1
　　return 0;
}
```

**7.2 指向函数的指针**

　　在C语言中，函数本身不是变量，但是可以定义指向函数的指针，也称作函数指针，函数指针指向函数的入口地址。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。 声明一个函数指针的方法如下：

```c
返回值类型 （* 指针变量名）（[形参列表]）;

int (*pointer)(int *,int *);        // 声明一个函数指针
```

　　上述代码声明了一个函数指针 pointer ，该指针指向一个函数，函数具有两个 int * 类型的参数，且返回值类型为 int。下面的代码演示了函数指针的用法：

```c
#include "stdio.h"
#include "string.h"

int str_comp(const char *m,const char *n);                             // 声明一个函数 str_comp，该函数有两个 const char 类型的指针，函数的返回值为 int 类型
void comp(char *a,char *b,int (*prr)(const char *,const char*));       // 声明一个函数 comp ,注意该函数的第三个参数，是一个函数指针

int main()
{
    char str1[20];      // 声明一个字符数组
    char str2[20];
    int (*p)(const char *,const char *) = str_comp;　　　　　　　　　　　 // 声明并初始化一个函数指针，该指针所指向的函数有两个 const char 类型的指针，且返回值为 int 类型
    gets(str1);         // 使用 gets() 函数从 I/O 读取一行字符串
    gets(str2);
    comp(str1,str2,p);  // 函数指针 p 作为参数传给 comp 函数
    return 0;
}

int str_comp(const char *m,const char *n)
{
　　 // 库函数 strcmp 用于比较两个字符串，其原型是： int strcmp(const char *s1,const char *s2);
    if(strcmp(m,n) == 0) 
        return 0;
    else
        return 1;
}

/* 函数 comp 接受一个函数指针作为它的第三个参数 */
void comp(char *a,char *b,int (*prr)(const char *,const char*))
{
    if((*prr)(a,b) == 0)
        printf("str1 = str2\n");
    else
        printf("str1 != str2\n");
} 
```

　　这段代码的功能是从键盘读取两行字符串（长度不超过20），判断二者是否相等。

　　注意，声明一个函数指针时，() 不能漏掉，否则：

```c
int *p(void *,void*);
```

　　这表明 p 是一个函数，该函数返回一个指向 int 类型的指针。





## 参考

###### [C语言———指针详解]https://www.cnblogs.com/skyzu2333/p/14890222.html