# 大端序和小端序

字节存储顺序主要分为`大端序`（Big-endian）和`小端序`（Little-endian），区别如下

- Big-endian：**高位**字节存入**低地址**，**低位**字节存入**高地址**
- Little-endian：**低位**字节存入**低地址**，**高位**字节存入**高地址**

![image-20250327153546649](https://picture-1344593885.cos.ap-beijing.myqcloud.com/image-20250327153546649.png)







**Zynq** 处理器（基于 **ARM Cortex-A9**）采用的是 **小端序（Little-Endian）** 存储方式。

在 C 代码中可以通过检查字节顺序来确认：

```c
#include <stdio.h>
int main() {
    int num = 0x1;
    char *ptr = (char *)&num;
    if (*ptr == 1) {
        printf("Little-Endian\n");
    } else {
        printf("Big-Endian\n");
    }
    return 0;
}
```

- 在 Zynq 上运行会输出 `Little-Endian`。

### **详细分析**

#### **1. 数据 `num = 0x00000001` 的存储方式**

- **32位整数的字节表示**（假设 `int` 是 4 字节）：

  ```
  值：0x00000001
  字节分解（从高到低）：0x00, 0x00, 0x00, 0x01
  ```

- **大端序（Big-Endian）**：高位字节在低地址

  ```
  内存地址增长方向：低地址 -> 高地址
  存储顺序：0x00（高字节） | 0x00 | 0x00 | 0x01（低字节）
  ```

- **小端序（Little-Endian）**：低位字节在低地址

  ```
  存储顺序：0x01（低字节） | 0x00 | 0x00 | 0x00（高字节）
  ```

#### **2. 关键代码解析**

```c
int num = 0x1;          // 32位整数，值为 0x00000001
char *ptr = (char *)&num; // 取 num 的起始地址（指向最低地址字节）
if (*ptr == 1) {        // 检查首字节的值
    printf("Little-Endian\n"); // 首字节=1 → 小端序
} else {
    printf("Big-Endian\n");    // 首字节=0 → 大端序
}
```

- `(char *)&num` 将 `int*` 转为 `char*`，从而可以逐字节访问。
- `*ptr` 读取 `num` 的第一个字节（最低地址字节）：
  - **小端序**：第一个字节是 `0x01` → 输出 `Little-Endian`。
  - **大端序**：第一个字节是 `0x00` → 输出 `Big-Endian`。

------

### **为什么能可靠检测？**

1. **`char\*` 访问的是内存的最小单元（1字节）**，不受对齐或类型转换影响。
2. `0x00000001` 的高低字节差异明显（首字节要么是 `0x00`，要么是 `0x01`），无歧义。
3. **ARM（如 Zynq）、x86 等常见架构均是小端序**，而网络协议（如 TCP/IP）或某些嵌入式芯片可能用大端序，此方法普适性强。

------

### **可能的误区**

- **`int` 的长度问题**：如果 `int` 不是 4 字节（如某些嵌入式平台是 2 字节），代码可能需调整（但 `0x1` 仍可检测）。
- **字节序的硬件依赖性**：某些系统（如 ARM）可配置大小端模式，但默认是小端序。